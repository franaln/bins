#! /usr/bin/env python3

import os
import re
import sys
import time
import glob
import shutil
import argparse
import subprocess
from datetime import datetime

C_WARNING = '\033[93m'
C_ERROR   = '\033[0;31m'
C_INFO    = '\033[0;32m'
C_RESET   = '\033[0m'

INFO = 0
GOOD = 1
WARNING = 2
ERROR  = 3

def print_msg(msg, level):
    if args.quiet:
        return

    if level == INFO:
        print(msg)
    elif level == GOOD:
        print(C_INFO + msg + C_RESET)
    elif level == WARNING:
        print(C_WARNING + msg + C_RESET)
    elif level == ERROR:
        print(C_ERROR + msg + C_RESET)


# templates
template_pandoc = r"""
\documentclass{beamer}
\usetheme{mini}

\input{physics.tex}
\input{susy.tex}

$if(verbatim-in-note)$
\usepackage{fancyvrb}
$endif$
$if(url)$
\usepackage{url}
$endif$
$if(graphics)$
\usepackage{graphicx}
\makeatletter
\def\ScaleIfNeeded{%
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother
\let\Oldincludegraphics\includegraphics
%\renewcommand{\includegraphics}[2][]{\Oldincludegraphics[width=\ScaleIfNeeded]{#2}}
$endif$

$for(header-includes)$
$header-includes$
$endfor$

$if(title)$
\title{$title$}
$endif$
$if(author)$
\author{$for(author)$$author$$sep$ \and $endfor$}
$endif$
$if(meeting)$
\date[$meeting$]{$date$}
$else$
\date[]{$date$}
$endif$

\begin{document}
\centering

$if(title)$
\frame{\titlepage}
$endif$

$body$

\end{document}
"""

template_slides = r"""
\documentclass[center,10pt,cm]{beamer}

\usetheme{mini}
\input{physics.tex}
\input{susy.tex}

\title{}
\author{Francisco Alonso}
\institute{UNLP/IFLP}
\date[]{\today}
%%\titlegraphic{\img{0.13}{iflp_logo.pdf}\hspace{0.8cm}\img{0.12}{atlas_logo.pdf}}

\begin{document}
\centering

\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}{}

\end{frame}

\end{document}
"""


def find_tex_file():
    tex_files = []
    for f in os.listdir('.'):
        if f.startswith('.'):
            continue
        if f.endswith('.tex'):
            tex_files.append(f)

    main = []
    if len(tex_files) == 1:
        return tex_files[0]
    else:
        for f in tex_files:
            try:
                tex = open(f).read()
                if r'\documentclass' in tex:
                    main.append(f)
            except:
                continue

    if not main:
        return None

    if len(main) > 1:
        print_msg('More than one main file was found', ERROR)
        return None
    else:
        return main[0]


def get_mtime(fname):
    return os.path.getmtime(fname)


def get_tex_dependencies(fname):

    dependencies = []
    for line in open(fname):
        line = line.replace('\n', '')

        dep = re.match(r'\\input{(.*)}', line)
        if dep is not None:
            dep = dep.groups()[0]
            if not '.' in dep:
                dep += '.tex'
            if os.path.isfile(dep):
                dependencies.append(dep)
            continue

        dep = re.match(r'\\include{(.*)}', line)
        if dep is not None:
            dep = dep.groups()[0]
            if not '.' in dep:
                dep += '.tex'
            if os.path.isfile(dep):
                dependencies.append(dep)
            continue

    return dependencies


def get_bibtex_style(main_tex):

    for line in open(main_tex):
        line = line.replace('\n', '')

        style = re.match(r'\\bibliographystyle{(.*)}', line)
        if style is not None:
            style = style.groups()[0]

            if os.path.isfile(style+'.bst'):
                return style
            continue

    return None


#
# Colorize LaTeX output.
#
def bytes_to_human(num):
    num = int(num)
    for unit in ['','K','M','G','T','P','E','Z']:
        if abs(num) < 1024.0:
            return "%3.1f %sB" % (num, unit)
        num /= 1024.0
    return "%.1f %sB" % (num, 'Y')


def colorize_latex_output(logfile, show=True):

    try:
        enc = 'iso-8859-15'
        log = open(logfile, 'r', encoding=enc).read().split('\n')
    except UnicodeDecodeError as e:
        raise

    line_error = re.compile('^\./(\w*.tex)\:(\d*)\: (.*)')

    n_warning = 0
    n_error = 0

    show_warnings = args.debug
    compile_ok = True
    compile_info = (0, 0, 0, 0)

    for i, line in enumerate(log):

        if 'Output written on' in line:

            try:
                sline = line.split()

                name = os.path.basename(sline[3])
                pages = sline[4][1:]
                size = bytes_to_human(sline[6])
                compile_info = (pages, size, n_warning, n_error)
            except:
                pass

            # for xelatex
            try:
                sline = line.split()

                name = sline[3]
                pages = sline[4][1:].replace(' pages', '')
                size = 0
                compile_info = (pages, size, n_warning, n_error)
            except:
                pass

        elif 'No pages of output' in line:
            compile_ok = False
            if show:
                print_msg(line, ERROR)

        elif 'no output PDF file produced!' in line:
            compile_ok = False
            if show:
                print_msg(line, ERROR)

        if 'Underfull' in line or 'Overfull' in line or 'Warning:' in line:
            n_warning += 1
            if show and show_warnings:
                print_msg(line, WARNING)

        if '*** (job aborted, no legal \end found)' in line:
            compile_ok = False
            if show:
                print_msg(line, ERROR)
            n_error += 1

        le = line_error.match(line)
        if le:
            if show:
                print_msg('%s (in %s, line %s)' % (le.groups()[2], le.groups()[0], le.groups()[1]), ERROR)
            n_error += 1

    return compile_ok, compile_info


def colorize_bibtex_output(logfile):

    re_updatefile = re.compile (".*INFO - Found BibTeX data source '(?P<filename>.*)'$")
    re_error = re.compile (".*Utils.pm:[0-9]+> (?P<kind>(WARN|ERROR)) .* line (?P<line>[0-9]+), (?P<text>.*)")

    try:
        log = open(logfile, "r")
    except:
        print_msg("cannot open bibtex logfile: %s" % logfile, WARNING)
        return

    with log:

        for line in log:
            m = re_updatefile.match (line)
            if m:
                current_bib = m.group ("filename")

            m = re_error.match (line)
            if m:
                print_msg('%s %s %s' (m.group("kind"), int(m.group("line")),  m.group("text")), INFO)


#
# Compile tex
#
def compile_tex(input_path, output_path):

    name = os.path.basename(input_path)[:-4]

    tmp_pdf_file = clatex_dir + '/%s.pdf' % name

    if args.only:
        filecmd = r'"\includeonly{%s}\input{%s}"' % (args.only, input_path)
    else:
        filecmd = input_path

    if args.verbose:
        pdflatex_cmd = '%s -output-directory=%s -file-line-error %s' % (args.engine, clatex_dir, filecmd)
    else:
        pdflatex_cmd = '%s -output-directory=%s -interaction=batchmode -file-line-error --shell-escape %s > /dev/null' % (args.engine, clatex_dir, filecmd)

    if os.path.isdir('images'):
        os.environ['TEXINPUTS'] = './/:./images//:'

    if os.path.isdir('figures'):
        os.environ['TEXINPUTS'] = './/:./figures//:'


    st = subprocess.call(pdflatex_cmd, shell=True)

    logfile = '%s/%s.log' % (clatex_dir, name)
    if os.path.isfile(logfile):
        compile_ok, compile_info = colorize_latex_output(logfile, False)

    if not os.path.isfile(tmp_pdf_file):
        compile_ok = False

    if compile_ok and args.bibtex:

        print('Running bibtex')
        pwd = os.getcwd()

        os.environ['TEXMFOUTPUT'] = clatex_dir+':'
        os.environ['BIBINPUTS'] = pwd + ':'
        os.environ['BSTINPUT'] = clatex_dir + ':' + pwd + ':'

        style = get_bibtex_style(texfile)

        if style is not None:
            os.system('cp %s.bst %s/%s' % (style, clatex_dir, style))

        os.chdir(clatex_dir)
        bibtex_cmd = 'bibtex %s.aux' % name
        os.system(bibtex_cmd)
        os.chdir(pwd)

        colorize_bibtex_output(clatex_dir + '/' + name+'.blg')

    if compile_ok and not args.fast:
        subprocess.call(pdflatex_cmd, shell=True)
        subprocess.call(pdflatex_cmd, shell=True)

    logfile = '%s/%s.log' % (clatex_dir, name)
    if os.path.isfile(logfile):
        compile_ok, compile_info = colorize_latex_output(logfile)

    if compile_ok and os.path.isfile(tmp_pdf_file):

        if is_table:
            crop_pdf(tmp_pdf_file, output_path)

        elif not args.tmp:
            subprocess.call(['mv', tmp_pdf_file, output_path])

        pages, size, n_warning, n_error = compile_info

        file_size = bytes_to_human(os.path.getsize(output_path))

        msg = 'Output written on %s, %s page(s), %s, %s warning(s), %s error(s).' % (output_path, pages, file_size, n_warning, n_error)
        print_msg(msg, GOOD)

    return compile_ok

#
# Create tex
#
def create_or_get_tex(inputs):

    """
    Find or create tex file

    if --tikz, --table or --plain: create new compilable tex file
    if --pdfs: create tex file from input pdfs
    """

    tex_path = None

    if args.pdfs:

        pdfs = []

        # Get pdf files from inputs. If input is None use all .pdf from current directory
        if inputs is None:
            pdfs = [ i for i in os.listdir('.') if i.endswith('.pdf') ]

        elif isinstance(inputs, list):
            for inp in inputs:
                if os.path.isdir(inputs):
                    pdfs.extend([ os.path.join(inputs, i) for i in os.listdir(inputs) if i.endswith('.pdf') ])
                else:
                    pdfs.extend([ i for i in inputs if i.endswith('.pdf') and os.path.isfile(i) ])
        else:
            if os.path.isdir(inputs):
                pdfs = [ os.path.join(inputs, i) for i in os.listdir(inputs) if i.endswith('.pdf') ]
            else:
                pdfs.append(inputs)

        # Filter pdfs
        if args.filter is not None:
            new_pdfs = []

            filters = args.filter.split(',')

            for pdf in pdfs:
                if all([ft in pdf for ft in filters]):
                    new_pdfs.append(pdf)

            pdfs = new_pdfs


        # Create tex
        tex_path = '%s/pdfs.tex' % clatex_dir if args.output is None else args.output

        create_pdfs_tex(pdfs, tex_path)

    else:

        if isinstance(inputs, str) and os.path.isfile(inputs):

            basename = os.path.splitext(os.path.basename(inputs))[0]

            # check tikz/table/plain
            text = open(inputs).read()

            is_tikz = args.tikz
            is_table = args.table
            is_plain = args.plain
            if r'\documentclass' not in text:
                if r'\begin{tikzpicture}' in text:
                    is_tikz = True
                elif r'\begin{tabular}' in text:
                    is_table = True
                else:
                    is_plain = True

            if is_tikz:

                if args.tex and args.output is not None:
                    tex_path = args.output
                else:
                    tex_path = '%s/%s.tex' % (clatex_dir, basename)

                print_msg('Creating tex %s --> %s' % (inputs, tex_path), INFO)
                create_tikz_tex(inputs, tex_path)

            elif is_table:

                if args.tex and args.output is not None:
                    tex_path = args.output
                else:
                    tex_path = '%s/%s.tex' % (clatex_dir, basename)

                print_msg('Creating tex %s --> %s' % (inputs, tex_path), INFO)
                create_table_tex(inputs, tex_path)

            elif is_plain:

                if args.tex and args.output is not None:
                    tex_path = args.output
                else:
                    tex_path = '%s/%s.tex' % (clatex_dir, basename)

                print_msg('Creating tex %s --> %s' % (inputs, tex_path), INFO)
                create_plain_tex(inputs, tex_path)

            else:
                tex_path = inputs


    return tex_path


def create_plain_tex(input_tex, output_tex):

    template_before = r"""\documentclass{article}
\usepackage[utf8]{inputenc}

\begin{document}
"""

    template_after = r"""
\end{document}
"""

    text = open(input_tex, 'r').read()

    with open(output_tex, 'wt', encoding='utf-8') as of:
        of.write(template_before)
        of.write(text)
        of.write(template_after)


def create_tikz_tex(input_tex, output_tex):

    template_before = r"""\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{mathptmx}
\usepackage{tikz}
\usetikzlibrary{patterns}
\usepackage{xifthen}

%\usepackage{color}
\usepackage[active,pdftex,tightpage]{preview}
\PreviewEnvironment[]{tikzpicture}
\PreviewEnvironment[]{pgfpicture}
\DeclareSymbolFont{symbolsb}{OMS}{cmsy}{m}{n}
\SetSymbolFont{symbolsb}{bold}{OMS}{cmsy}{b}{n}
\DeclareSymbolFontAlphabet{\mathcal}{symbolsb}
\begin{document}
"""

    template_after = r"""
\end{document}
"""

    tikzplot = open(input_tex, 'r').read()

    with open(output_tex, 'wt', encoding='utf-8') as of:
        of.write(template_before)
        of.write(tikzplot)
        of.write(template_after)


def create_table_tex(input_tex, output_tex):

    tex = r'\documentclass{article} \usepackage{graphicx} \usepackage[landscape]{geometry} \begin{document} \pagestyle{empty}'
    tex += '\n'
    tex += open(input_tex).read()
    tex += '\n\\end{document}'

    with open(output_tex, 'wt', encoding='utf-8') as of:
        of.write(tex)


def create_pdfs_tex(input_pdfs, output_tex_path):

    header = r"""%% Created with clatex
\documentclass[center,10pt,cm]{beamer}

% basic style
\renewcommand\familydefault{\rmdefault}
\setbeamercolor*{frametitle}{bg=white,fg=black}
\setbeamertemplate{navigation symbols}{}

\begin{document}
\centering

   """

    footer = r"""

\end{document}
"""

    body = ""
    counter = 0

    for pdf in sorted(input_pdfs):

        if not pdf.endswith('.pdf'):
            continue

        title = pdf[:-4].replace('_', '\_')

        if len(title) > 75:
            title = '{\\tiny %s}' % title
        elif len(title) > 60:
            title = '{\\scriptsize %s}' % title
        elif len(title) > 45:
            title = '{\\small %s}' % title

        body += r"""
\begin{frame}{%s}
    \includegraphics[width=0.9\textwidth,height=0.9\textheight,keepaspectratio]{%s}
\end{frame}
""" % (title, pdf)
        counter += 1

    if not body:
        return None

    text = header + body + footer

    with open(output_tex_path, 'w+') as f:
        f.write(text)

    print_msg('Created slides "%s" with %i pdfs' % (output_tex_path, counter), GOOD)

    return


def convert_image(fname):
    iname = fname
    oname = os.path.splitext(fname)[0] + '.pdf'
    cmd = 'convert %s %s' % (iname, oname)
    os.system(cmd)


def crop_pdf(input_pdf, output_pdf):
    os.system('pdfcrop {0} {1} > /dev/null'.format(input_pdf, output_pdf))


def move_file(old_path, new_path):
    shutil.move(old_path, new_path)

def clean(fname):
    try:
        os.unlink(fname)
    except FileNotFoundError:
        pass
    except IsADirectoryError:
        shutil.rmtree(fname)



def main():

    parser = argparse.ArgumentParser(description='Compile latex')

    parser.add_argument('inputs', nargs='*', help='')
    parser.add_argument('-f', dest='force',   action='store_true', help='Force compilation')
    parser.add_argument('-c', dest='clean',   action='store_true', help='Clean all')
    parser.add_argument('-g', dest='debug',   action='store_true', help='Show warnings')
    parser.add_argument('-q', dest='quiet',   action='store_true', help='No prints to std out')
    parser.add_argument('-o', dest='output',  help='Output pdf name (or output tex name if -t option used)')
    parser.add_argument('-p', dest='open_pdf', action='store_true', help='Open final pdf')
    parser.add_argument('-v', dest='verbose', action='store_true', help='Show latex output')
    parser.add_argument('-b', dest='bibtex',  action='store_true', help='Compile bibliography using bibtex')
    parser.add_argument('-a', dest='fast',    action='store_true', help='Compile only once')
    parser.add_argument('-j', dest='only',    default='', help='Include only')
    parser.add_argument('-t', '--tex', help='Intermediary tex output name')
    parser.add_argument('--onlytex', action='store_true', help='Only create tex, don\'t compile')
    parser.add_argument('-z', '--tmp', action='store_true', help='Compile in /tmp.')
    parser.add_argument('-k', '--keep-tmp-files', dest='keep_tmp_files', action='store_true', help='Keep tmp files')
    parser.add_argument('-e', '--engine',  default='pdflatex', help='Latex engine: pdflatex (default), xelatex, lualatex, ...')
    parser.add_argument('--tikz',  action='store_true', help='Compile tikz picture')
    parser.add_argument('--table', action='store_true', help='Compile table')
    parser.add_argument('--plain', action='store_true', help='Compile plain text')
    parser.add_argument('--pdfs', action='store_true', help='Merge pdfs in slides')
    parser.add_argument('--filter', help='Filter files (to use with --pdfs)')
    parser.add_argument('--loop', action='store_true', help='Create and compile every 5 seconds.')
    parser.add_argument('--sleep', type=int)

    # Templates
    parser.add_argument('--slides', help='Create slides template')
    parser.add_argument('--slidesdir', help='Create slides directory with template')


    global args
    args = parser.parse_args()


    global clatex_dir
    clatex_dir = '/tmp/clatex' if args.tmp else '.clatex'

    global is_table ## UHM: FIX!
    is_table = args.table

    #
    # Templates (create and exit!)
    #
    if args.slidesdir is not None:
        name = args.slidesdir

        print_msg('Creating slides directory in %s' % name, GOOD)

        os.system('mkdir -p %s' % name)
        os.system('mkdir -p %s/images' % name)

        with open('%s/slides.tex' % name, 'w+') as f:
            f.write(template_slides)

        return 0

    elif args.slides is not None:
        name = args.slides

        print_msg('Created slides template: %s.tex' % name, GOOD)

        with open('%s.tex' % name, 'w+') as f:
            f.write(template_slides)

        return 0


    # clean clatex dir
    if args.clean:
        clean(clatex_dir)
        return 0

    if args.force or args.loop:
        clean(clatex_dir)


    # create clatex dir
    try:
        os.makedirs(clatex_dir)
    except OSError as exception:
        pass



    #
    # Find tex or create tmp tex if necessary
    #
    if not args.inputs:
        inputs = find_tex_file()
    elif len(args.inputs) == 1:
        inputs = args.inputs[0]
    else:
        inputs = args.inputs

    main_tex = create_or_get_tex(inputs)

    if main_tex is None:
        print_msg('There is no tex to compile...', ERROR)
        return 1


    main_name = os.path.splitext(os.path.basename(main_tex))[0]

    main_pdf = '%s.pdf' % main_name if args.output is None else args.output

    if args.tmp:
        main_pdf = '%s/%s' % (clatex_dir, main_pdf)

    # exit now if only create tex option is used
    if args.tex:
        return 0

    #
    # Compilation
    #
    print_msg('Compiling tex %s --> %s' % (main_tex, main_pdf), INFO)

    need_compile = False
    if args.force or not os.path.isfile(main_pdf):
        need_compile = True
    else:
        main_pdf_time = datetime.fromtimestamp(get_mtime(main_pdf))
        main_tex_time = datetime.fromtimestamp(get_mtime(main_tex))

        diff = (main_tex_time - main_pdf_time).total_seconds()
        if diff > 0:
            need_compile = True
        else:
            for dep in get_tex_dependencies(main_tex):
                dep_time = datetime.fromtimestamp(get_mtime(dep))
                if (dep_time - main_pdf_time).total_seconds() > 0:
                    need_compile = True
                    break

    if need_compile:
        compile_ok = compile_tex(main_tex, main_pdf)
        if not compile_ok:
            return 1

    else:
        print_msg('Nothing to be done', INFO)


    # Loop compile
    if args.loop:
        sleep_interval = args.sleep if args.sleep is not None else 5

        while True:
            try:
                time.sleep(sleep_interval)
                create_or_get_tex(inputs)
                compile_tex(main_tex, main_pdf)
            except KeyboardInterrupt:
                print('Stopped')
                return 0


    # Open output pdf
    if args.open_pdf:
        subprocess.call(['open', main_pdf])


    # Clean temporary files
    if not args.keep_tmp_files and not args.tmp:
        clean(clatex_dir)


if __name__ == '__main__':
    main()
