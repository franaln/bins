#! /usr/bin/env python3

import os
import re
import sys
import time
import shutil
import argparse
import subprocess
from datetime import datetime

C_WARNING = '\033[93m'
C_ERROR   = '\033[0;31m'
C_INFO    = '\033[0;32m'
C_RESET   = '\033[0m'

def print_info(msg):
    print(C_INFO + msg + C_RESET)

def print_warning(msg):
    print(C_WARNING + msg + C_RESET)

def print_error(msg):
    print(C_ERROR + msg + C_RESET)


def find_tex_file():
    tex_files = []
    for f in os.listdir('.'):
        if f.startswith('.'):
            continue
        if f.endswith('.tex'):
            tex_files.append(f)

    main = []
    if len(tex_files) == 1:
        return tex_files[0]
    else:
        for f in tex_files:
            try:
                tex = open(f).read()
                if r'\documentclass' in tex:
                    main.append(f)
            except:
                continue

    if not main:
        return None

    if len(main) > 1:
        print_error('More than one main file was found')
        return None
    else:
        return main[0]


def get_mtime(fname):
    return os.path.getmtime(fname)


def get_dependence(fname):
    dependence = []
    for line in open(fname):
        line = line.replace('\n', '')

        dep = re.match(r'\\input{(.*)}', line)
        if dep is not None:
            dep = dep.groups()[0]
            if not '.' in dep:
                dep += '.tex'
            dependence.append(dep)
            continue

        dep = re.match(r'\\include{(.*)}', line)
        if dep is not None:
            dep = dep.groups()[0]
            if not '.' in dep:
                dep += '.tex'
            dependence.append(dep)
            continue

    return dependence


def check_tikz_picture(fname):
    text = open(fname).read()
    return (r'\documentclass' not in text and r'\begin{tikzpicture}' in text)

# Colorize LaTeX output.

def bytes_to_human(num):
    num = int(num)
    for unit in ['','K','M','G','T','P','E','Z']:
        if abs(num) < 1024.0:
            return "%3.1f%sB" % (num, unit)
        num /= 1024.0
    return "%.1f%sB" % (num, 'Y')


def colorize_latex_output(logfile):

    try:
        enc='iso-8859-15'
        log = open(logfile, 'r', encoding=enc).read().split('\n')
    except UnicodeDecodeError as e:
        raise

    line_error = re.compile('^\./(\w*.tex)\:(\d*)\: (.*)')

    n_warning = 0
    n_error = 0
    show_warnings = args.debug
    compile_ok = True
    for i, line in enumerate(log):

        if 'Output written on' in line:
            sline = line.split()

            name = sline[3]
            pages = sline[4][1:]
            size = bytes_to_human(sline[6])

            msg = 'Output written on %s. %s pages, %s, %s warnings, %s errors.' % (os.path.basename(name), pages, size, n_warning, n_error)
            print_info(msg)

        elif 'No pages of output' in line:
            compile_ok = False
            print_info(line)

        elif 'no output PDF file produced!' in line:
            compile_ok = False
            print_error(line)

        if 'Underfull' in line or 'Overfull' in line or 'Warning:' in line:
            n_warning += 1
            if show_warnings:
                print_warning(line)

        if '*** (job aborted, no legal \end found)' in line:
            print_error(line)
            n_error += 1

        le = line_error.match(line)
        if le:
            print_error('%s (in %s, line %s)' % (le.groups()[2], le.groups()[0], le.groups()[1]))
            n_error += 1

    return compile_ok


def colorize_bibtex_output(logfile):

    re_updatefile = re.compile (".*INFO - Found BibTeX data source '(?P<filename>.*)'$")
    re_error = re.compile (".*Utils.pm:[0-9]+> (?P<kind>(WARN|ERROR)) .* line (?P<line>[0-9]+), (?P<text>.*)")

    try:
        log = open (self.blg, "r")
    except:
        msg.warn (_("cannot open Biber logfile: %s") % self.blg, pkg="biblatex")
        return

    with log:
        for line in log:
            m = re_updatefile.match (line)
            if m:
                current_bib = m.group ("filename")

            m = re_error.match (line)
            if m:
                print(m.group ("kind"),
                      int(m.group ("line")),
                      m.group ("text"))



def compile_latex(texfile):

    name = os.path.basename(texfile)[:-4]
    pdf_file = clatex_dir+'/%s.pdf' % name

    if args.only:
        filecmd = r'"\includeonly{%s}\input{%s}"' % (args.only, texfile)
    else:
        filecmd = texfile

    if args.verbose:
        pdflatex_cmd = 'pdflatex -output-directory=%s -file-line-error %s' % (clatex_dir, filecmd)
    else:
        pdflatex_cmd = 'pdflatex -output-directory=%s -interaction=batchmode -file-line-error --shell-escape %s > /dev/null' % (clatex_dir, filecmd)

    if os.path.isdir('images'):
        os.environ['TEXINPUTS'] = './/:./images//:'

    if os.path.isdir('figures'):
        os.environ['TEXINPUTS'] = './/:./figures//:'


    st = subprocess.call(pdflatex_cmd, shell=True)

    logfile = '%s/%s.log' % (clatex_dir, name)
    if os.path.isfile(logfile):
        compile_ok = colorize_latex_output(logfile)

    if not os.path.isfile(pdf_file):
        compile_ok = False

    if compile_ok and args.bibtex:
        print_info('-- Running bibtex')
        pwd = os.getcwd()

        os.environ['TEXMFOUTPUT'] = clatex_dir+':'
        os.environ['BIBINPUTS'] = pwd + ':'
        os.environ['BSTINPUT'] = clatex_dir + ':'

        os.chdir(clatex_dir)
        bibtex_cmd = 'bibtex %s.aux' % name
        os.system(bibtex_cmd)
        os.chdir(pwd)

        colorize_bibtex_output(clatex_dir + '/' + name+'.blg')

    if compile_ok and not args.fast:
        subprocess.call(pdflatex_cmd, shell=True)
        subprocess.call(pdflatex_cmd, shell=True)


    if compile_ok and os.path.isfile(pdf_file):

        pdf_file_final = '%s.pdf' % name

        if args.table:
            crop_pdf(pdf_file, pdf_file_final)
        else:
            os.system('cp %s %s' % (pdf_file, pdf_file_final))


    return compile_ok


def create_tikz_tex(input_tex, output_tex):

    template_before = r"""\documentclass{article}
\usepackage{mathptmx}
\usepackage{tikz}
\usetikzlibrary{patterns}
\usepackage{xifthen}

%\usepackage{color}
\usepackage[active,pdftex,tightpage]{preview}
\PreviewEnvironment[]{tikzpicture}
\PreviewEnvironment[]{pgfpicture}
\DeclareSymbolFont{symbolsb}{OMS}{cmsy}{m}{n}
\SetSymbolFont{symbolsb}{bold}{OMS}{cmsy}{b}{n}
\DeclareSymbolFontAlphabet{\mathcal}{symbolsb}
\begin{document}
"""

    template_after = r"""
\end{document}
"""

    tikzplot = open(input_tex, 'r').read()

    with open(output_tex, 'wt', encoding='utf-8') as of:
        of.write(template_before)
        of.write(tikzplot)
        of.write(template_after)


def create_table_tex(input_tex, output_tex):

    tex = r'\documentclass{article} \usepackage{graphicx} \usepackage[landscape]{geometry} \begin{document} \pagestyle{empty}'
    tex += '\n'
    tex += open(input_tex).read()
    tex += '\n\\end{document}'

    with open(output_tex, 'wt', encoding='utf-8') as of:
        of.write(tex)


def convert_image(fname):
    iname = fname
    oname = fname[:-4] + '.pdf'
    cmd = 'convert %s %s' % (iname, oname)
    os.system(cmd)


def crop_pdf(input_pdf, output_pdf):
    os.system('pdfcrop {0} {1} > /dev/null'.format(input_pdf, output_pdf))


def clean(fname):
    try:
        os.unlink(fname)
    except FileNotFoundError:
        pass
    except IsADirectoryError:
        shutil.rmtree(fname)


def create_slides_from_plots(output_tex):

    header = r"""
\documentclass[center,10pt,cm]{beamer}

% basic style
\renewcommand\familydefault{\rmdefault}
\setbeamercolor*{frametitle}{bg=white,fg=black}
\setbeamertemplate{navigation symbols}{}

\begin{document}
\centering

   """

    footer = r"""

\end{document}
"""

    body = ""
    counter = 0
    for img in sorted(os.listdir('.')):

        if not img.endswith('.pdf'):
            continue

        title = img[:-4].replace('_', '\_')

        body += r"""
\begin{frame}{%s}
    \includegraphics[width=0.9\textwidth,height=0.9\textheight,keepaspectratio]{%s}
\end{frame}
""" % (title, img)
        counter += 1

    if not body:
        return None

    text = header + body + footer

    with open(output_tex, 'w+') as f:
        f.write(text)

    print_info('Created slides "%s" with %i plots' % (output_tex, counter))

    return output_tex


def main():

    parser = argparse.ArgumentParser()

    parser.add_argument('texfile', nargs='?', help='')
    parser.add_argument('-f', dest='force',   action='store_true', help='force compilation')
    parser.add_argument('-c', dest='clean',   action='store_true', help='clean all')
    parser.add_argument('-g', dest='debug',   action='store_true', help='show warnings')
    parser.add_argument('-o', dest='open',    action='store_true', help='open pdf')
    parser.add_argument('-v', dest='verbose', action='store_true', help='show latex output')
    parser.add_argument('-b', dest='bibtex',  action='store_true', help='compile bibliography using bibtex')
    parser.add_argument('-a', dest='fast',    action='store_true', help='compile only once')
    parser.add_argument('-j', dest='only',    default='', help='include only')
    parser.add_argument('-t', dest='temp',    action='store_true', help='compile in /tmp.')

    parser.add_argument('--tikz', action='store_true', help='compile tikz picture')
    parser.add_argument('--plots', action='store_true', help='merge plots in slides')
    parser.add_argument('--table', action='store_true', help='compile table')

    parser.add_argument('--loop', action='store_true', help='Compile every 5 seconds')
    #while true ; do clatex --tikz topoetcone.tex ; sleep 5 ; done
        # if args.loop:
        #     while True:
        #         time.sleep(5)
        #         compile_ok = compile_latex(main_tex)
        #         if not compile_ok:
        #             return 1


    global args
    args = parser.parse_args()

    global clatex_dir
    clatex_dir = '/tmp/clatex' if args.temp else '.clatex'

    if args.clean:
        clean(clatex_dir)
        return 0

    if args.force or args.loop:
        clean(clatex_dir)

    # create clatex dir
    subprocess.call('mkdir -p %s' % clatex_dir, shell=True)


    main_tex = None
    if args.texfile is not None:

        main_tex = args.texfile
        main_name = os.path.basename(main_tex)[:-4]

        if args.tikz:

            tmp_tex = clatex_dir + '/' + main_name + '.tex'

            print_info('Creating %s -> %s' % (main_tex, tmp_tex))

            create_tikz_tex(main_tex, tmp_tex)

            main_tex = tmp_tex

        elif args.table:

            tmp_tex = clatex_dir + '/' + main_name + '.tex'

            print_info('Creating %s -> %s' % (main_tex, tmp_tex))

            create_table_tex(main_tex, tmp_tex)

            main_tex = tmp_tex


    if args.plots:

        texfile = clatex_dir + '/plots.tex' if main_tex is None else main_tex
        print_info('Creating %s' % (texfile))
        main_tex = create_slides_from_plots(texfile)


    if main_tex is None:
        main_tex = find_tex_file()

    if main_tex is None:
        print_error('There is no tex to compile...')
        return 1

    main_name = os.path.basename(main_tex)[:-4]
    main_pdf = main_name + '.pdf'


    # Compile
    print_info('Compiling %s -> %s' % (main_tex, main_pdf))

    need_compile = False
    if args.force or not os.path.isfile(main_pdf):
        need_compile = True
    else:
        main_pdf_time = datetime.fromtimestamp(get_mtime(main_pdf))
        main_tex_time = datetime.fromtimestamp(get_mtime(main_tex))

        diff = (main_tex_time-main_pdf_time).total_seconds()
        if diff > 0:
            need_compile = True
        else:
            for dep in get_dependence(main_tex):
                dep_time = datetime.fromtimestamp(get_mtime(dep))
                if (main_pdf_time - dep_time).total_seconds() < 0:
                    need_compile = True
                    break


    if need_compile:
        compile_ok = compile_latex(main_tex)
        if not compile_ok:
            return 1

    else:
        print_info('Nothing to be done')


    if args.open:
        subprocess.call(['open', main_pdf])


if __name__ == '__main__':
    main()
