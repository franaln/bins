#! /usr/bin/env python3

import os
import re
import sys
import time
import glob
import shutil
import argparse
import subprocess
from datetime import datetime

C_WARNING = '\033[93m'
C_ERROR   = '\033[0;31m'
C_INFO    = '\033[0;32m'
C_RESET   = '\033[0m'

def print_info(msg):
    print(C_INFO + msg + C_RESET)

def print_warning(msg):
    print(C_WARNING + msg + C_RESET)

def print_error(msg):
    print(C_ERROR + msg + C_RESET)


# templates
template_pandoc = r"""
\documentclass{beamer}
\usetheme{mini}

\input{physics.tex}
\input{susy.tex}

$if(verbatim-in-note)$
\usepackage{fancyvrb}
$endif$
$if(url)$
\usepackage{url}
$endif$
$if(graphics)$
\usepackage{graphicx}
\makeatletter
\def\ScaleIfNeeded{%
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother
\let\Oldincludegraphics\includegraphics
%\renewcommand{\includegraphics}[2][]{\Oldincludegraphics[width=\ScaleIfNeeded]{#2}}
$endif$

$for(header-includes)$
$header-includes$
$endfor$

$if(title)$
\title{$title$}
$endif$
$if(author)$
\author{$for(author)$$author$$sep$ \and $endfor$}
$endif$
$if(meeting)$
\date[$meeting$]{$date$}
$else$
\date[]{$date$}
$endif$

\begin{document}
\centering

$if(title)$
\frame{\titlepage}
$endif$

$body$

\end{document}
"""


template_slides = r"""
\documentclass[center,10pt,cm]{beamer}

\usetheme{mini}
\input{physics.tex}

\title{Title}
\author{Francisco Alonso}
\institute{UNLP/IFLP}
\date[meeting]{\today}

\begin{document}
\centering

\begin{frame}[plain]
  \titlepage
\end{frame}

\begin{frame}{Title}

\end{frame}

\end{document}
"""


def find_tex_file():
    tex_files = []
    for f in os.listdir('.'):
        if f.startswith('.'):
            continue
        if f.endswith('.tex'):
            tex_files.append(f)

    main = []
    if len(tex_files) == 1:
        return tex_files[0]
    else:
        for f in tex_files:
            try:
                tex = open(f).read()
                if r'\documentclass' in tex:
                    main.append(f)
            except:
                continue

    if not main:
        return None

    if len(main) > 1:
        print_error('More than one main file was found')
        return None
    else:
        return main[0]


def get_mtime(fname):
    return os.path.getmtime(fname)


def get_tex_dependencies(fname):

    dependencies = []
    for line in open(fname):
        line = line.replace('\n', '')

        dep = re.match(r'\\input{(.*)}', line)
        if dep is not None:
            dep = dep.groups()[0]
            if not '.' in dep:
                dep += '.tex'
            if os.path.isfile(dep):
                dependencies.append(dep)
            continue

        dep = re.match(r'\\include{(.*)}', line)
        if dep is not None:
            dep = dep.groups()[0]
            if not '.' in dep:
                dep += '.tex'
            if os.path.isfile(dep):
                dependencies.append(dep)
            continue

    return dependencies


def check_tikz_picture(fname):
    text = open(fname).read()
    return (r'\documentclass' not in text and r'\begin{tikzpicture}' in text)


# Colorize LaTeX output.
def bytes_to_human(num):
    num = int(num)
    for unit in ['','K','M','G','T','P','E','Z']:
        if abs(num) < 1024.0:
            return "%3.1f%sB" % (num, unit)
        num /= 1024.0
    return "%.1f%sB" % (num, 'Y')


def colorize_latex_output(logfile, show=True):

    try:
        enc = 'iso-8859-15'
        log = open(logfile, 'r', encoding=enc).read().split('\n')
    except UnicodeDecodeError as e:
        raise

    line_error = re.compile('^\./(\w*.tex)\:(\d*)\: (.*)')

    n_warning = 0
    n_error = 0

    show_warnings = args.debug
    compile_ok = True

    for i, line in enumerate(log):

        if 'Output written on' in line:

            try:
                sline = line.split()

                name = os.path.basename(sline[3])
                pages = sline[4][1:]
                size = bytes_to_human(sline[6])

                msg = 'Output written on %s. %s pages, %s, %s warnings, %s errors.' % (name, pages, size, n_warning, n_error)

            except:
                msg = line

            if show:
                print_info(msg)

        elif 'No pages of output' in line:
            compile_ok = False
            if show:
                print_info(line)

        elif 'no output PDF file produced!' in line:
            compile_ok = False
            if show:
                print_error(line)

        if 'Underfull' in line or 'Overfull' in line or 'Warning:' in line:
            n_warning += 1
            if show and show_warnings:
                print_warning(line)

        if '*** (job aborted, no legal \end found)' in line:
            compile_ok = False
            if show:
                print_error(line)
            n_error += 1

        le = line_error.match(line)
        if le:
            if show:
                print_error('%s (in %s, line %s)' % (le.groups()[2], le.groups()[0], le.groups()[1]))
            n_error += 1

    return compile_ok


def colorize_bibtex_output(logfile):

    re_updatefile = re.compile (".*INFO - Found BibTeX data source '(?P<filename>.*)'$")
    re_error = re.compile (".*Utils.pm:[0-9]+> (?P<kind>(WARN|ERROR)) .* line (?P<line>[0-9]+), (?P<text>.*)")

    try:
        log = open(logfile, "r")
    except:
        print_warning("cannot open bibtex logfile: %s" % logfile)
        return

    with log:

        for line in log:
            m = re_updatefile.match (line)
            if m:
                current_bib = m.group ("filename")

            m = re_error.match (line)
            if m:
                print_info(m.group("kind"),
                      int(m.group("line")),
                      m.group("text"))



def compile_tex(texfile):

    name = os.path.basename(texfile)[:-4]
    pdf_file = clatex_dir+'/%s.pdf' % name

    if args.only:
        filecmd = r'"\includeonly{%s}\input{%s}"' % (args.only, texfile)
    else:
        filecmd = texfile

    if args.verbose:
        pdflatex_cmd = '%s -output-directory=%s -file-line-error %s' % (latex_engine, clatex_dir, filecmd)
    else:
        pdflatex_cmd = '%s -output-directory=%s -interaction=batchmode -file-line-error --shell-escape %s > /dev/null' % (latex_engine, clatex_dir, filecmd)

    if os.path.isdir('images'):
        os.environ['TEXINPUTS'] = './/:./images//:'

    if os.path.isdir('figures'):
        os.environ['TEXINPUTS'] = './/:./figures//:'


    st = subprocess.call(pdflatex_cmd, shell=True)

    logfile = '%s/%s.log' % (clatex_dir, name)
    if os.path.isfile(logfile):
        compile_ok = colorize_latex_output(logfile, False)

    if not os.path.isfile(pdf_file):
        compile_ok = False

    if compile_ok and args.bibtex:

        print('Running bibtex')
        pwd = os.getcwd()

        os.environ['TEXMFOUTPUT'] = clatex_dir+':'
        os.environ['BIBINPUTS'] = pwd + ':'
        os.environ['BSTINPUT'] = clatex_dir + ':' + pwd + ':'

        os.chdir(clatex_dir)
        bibtex_cmd = 'bibtex %s.aux' % name
        os.system(bibtex_cmd)
        os.chdir(pwd)

        colorize_bibtex_output(clatex_dir + '/' + name+'.blg')

    if compile_ok and not args.fast:
        subprocess.call(pdflatex_cmd, shell=True)
        subprocess.call(pdflatex_cmd, shell=True)

    logfile = '%s/%s.log' % (clatex_dir, name)
    if os.path.isfile(logfile):
        compile_ok = colorize_latex_output(logfile)

    if compile_ok and os.path.isfile(pdf_file) and not args.tmp:

        pdf_file_final = '%s.pdf' % name

        if args.table or name.startswith('table'):
            crop_pdf(pdf_file, pdf_file_final)
        else:
            subprocess.call(['cp', pdf_file, pdf_file_final])


    return compile_ok


def get_tex():

    tex = None
    if args.texfile is not None and os.path.isfile(args.texfile):

        fname = args.texfile
        name = os.path.splitext(os.path.basename(fname))[0]

        if fname.endswith('.sld'):
            tex = name + '.tex'
            #subprocess.call(['beamerize', fname])
            subprocess.call(['slidify', fname])

        elif fname.endswith('.md'):

            tex = name + '.tex'

            print('Converting %s -> %s' % (fname, tex))

            template_file = '%s/template.beamer' % clatex_dir

            if not os.path.exists(template_file):
                with open(template_file, 'wt', encoding='utf-8') as of:
                    of.write(template_pandoc)

            pandoc_cmd = 'pandoc -t beamer --template=%s %s -o %s' % (template_file, fname, tex)
            subprocess.call(pandoc_cmd, shell=True)

        elif args.tikz:

            tex = clatex_dir + '/' + name + '.tex'

            create_tikz_tex(fname, tex)

        elif args.table or fname.startswith('table'):

            tex = clatex_dir + '/' + name + '.tex'

            create_table_tex(fname, tex)

        else:
            tex = fname

    if args.plots:

        texfile = clatex_dir + '/plots.tex' if tex is None else tex

        tex = create_plots_tex(texfile, args.only)


    if tex is None:
        tex = find_tex_file()


    return tex


def create_tikz_tex(input_tex, output_tex):

    template_before = r"""\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{mathptmx}
\usepackage{tikz}
\usetikzlibrary{patterns}
\usepackage{xifthen}

%\usepackage{color}
\usepackage[active,pdftex,tightpage]{preview}
\PreviewEnvironment[]{tikzpicture}
\PreviewEnvironment[]{pgfpicture}
\DeclareSymbolFont{symbolsb}{OMS}{cmsy}{m}{n}
\SetSymbolFont{symbolsb}{bold}{OMS}{cmsy}{b}{n}
\DeclareSymbolFontAlphabet{\mathcal}{symbolsb}
\begin{document}
"""

    template_after = r"""
\end{document}
"""

    tikzplot = open(input_tex, 'r').read()

    with open(output_tex, 'wt', encoding='utf-8') as of:
        of.write(template_before)
        of.write(tikzplot)
        of.write(template_after)



def create_table_tex(input_tex, output_tex):

    tex = r'\documentclass{article} \usepackage{graphicx} \usepackage[landscape]{geometry} \begin{document} \pagestyle{empty}'
    tex += '\n'
    tex += open(input_tex).read()
    tex += '\n\\end{document}'

    with open(output_tex, 'wt', encoding='utf-8') as of:
        of.write(tex)


def create_plots_tex(output_tex, only):

    header = r"""
\documentclass[center,10pt,cm]{beamer}

% basic style
\renewcommand\familydefault{\rmdefault}
\setbeamercolor*{frametitle}{bg=white,fg=black}
\setbeamertemplate{navigation symbols}{}

\begin{document}
\centering

   """

    footer = r"""

\end{document}
"""

    body = ""
    counter = 0

    if only:
        images = glob.glob(only)
    else:
        images = [ i for i in os.listdir('.') if i.endswith('.pdf') ]

    for img in sorted(images):

        if not img.endswith('.pdf'):
            continue

        title = img[:-4].replace('_', '\_')

        body += r"""
\begin{frame}{%s}
    \includegraphics[width=0.9\textwidth,height=0.9\textheight,keepaspectratio]{%s}
\end{frame}
""" % (title, img)
        counter += 1

    if not body:
        return None

    text = header + body + footer

    with open(output_tex, 'w+') as f:
        f.write(text)

    print('Created slides "%s" with %i plots' % (output_tex, counter))

    return output_tex


def convert_image(fname):
    iname = fname
    oname = os.path.splitext(fname)[0] + '.pdf'
    cmd = 'convert %s %s' % (iname, oname)
    os.system(cmd)


def crop_pdf(input_pdf, output_pdf):
    os.system('pdfcrop {0} {1} > /dev/null'.format(input_pdf, output_pdf))


def clean(fname):
    try:
        os.unlink(fname)
    except FileNotFoundError:
        pass
    except IsADirectoryError:
        shutil.rmtree(fname)




def main():

    parser = argparse.ArgumentParser()

    parser.add_argument('texfile', nargs='?', help='')
    parser.add_argument('-f', dest='force',   action='store_true', help='force compilation')
    parser.add_argument('-c', dest='clean',   action='store_true', help='clean all')
    parser.add_argument('-g', dest='debug',   action='store_true', help='show warnings')
    parser.add_argument('-o', dest='open',    action='store_true', help='open pdf')
    parser.add_argument('-v', dest='verbose', action='store_true', help='show latex output')
    parser.add_argument('-b', dest='bibtex',  action='store_true', help='compile bibliography using bibtex')
    parser.add_argument('-a', dest='fast',    action='store_true', help='compile only once')
    parser.add_argument('-j', dest='only',    default='', help='include only')
    parser.add_argument('-t', '--tex', action='store_true', help='only create tex. don\'t compile')
    parser.add_argument('-z', '--tmp', action='store_true', help='compile in /tmp.')
    parser.add_argument('--tikz', action='store_true', help='compile tikz picture')
    parser.add_argument('--plots', action='store_true', help='merge plots in slides')
    parser.add_argument('--table', action='store_true', help='compile table')
    parser.add_argument('--template', help='')
    parser.add_argument('--loop', action='store_true', help='create and compile every 5 seconds.')
    parser.add_argument('--sleep', type=int)
    parser.add_argument('-e', '--engine',  default='pdflatex', help='latex engine')


    global args
    args = parser.parse_args()


    global clatex_dir
    clatex_dir = '/tmp/clatex' if args.tmp else '.clatex'

    global latex_engine
    latex_engine = args.engine

    # templates
    if args.template:
        print('created')

        return 0


    # clean
    if args.clean:
        clean(clatex_dir)
        return 0

    if args.force or args.loop:
        clean(clatex_dir)


    # create clatex dir
    try:
        os.makedirs(clatex_dir)
    except OSError as exception:
        pass

    # create/find tex
    main_tex = get_tex()

    if main_tex is None:
        print('There is no tex to compile...')
        return 1

    main_name = os.path.splitext(os.path.basename(main_tex))[0]
    main_pdf = main_name + '.pdf'

    if args.tex:
        return 0

    # compile
    print('Compiling %s -> %s' % (main_tex, main_pdf))

    need_compile = False
    if args.force or not os.path.isfile(main_pdf):
        need_compile = True
    else:
        main_pdf_time = datetime.fromtimestamp(get_mtime(main_pdf))
        main_tex_time = datetime.fromtimestamp(get_mtime(main_tex))

        diff = (main_tex_time - main_pdf_time).total_seconds()
        if diff > 0:
            need_compile = True
        else:
            for dep in get_tex_dependencies(main_tex):
                dep_time = datetime.fromtimestamp(get_mtime(dep))
                if (dep_time - main_pdf_time).total_seconds() > 0:
                    need_compile = True
                    break


    if need_compile:
        compile_ok = compile_tex(main_tex)
        if not compile_ok:
            return 1

    else:
        print('Nothing to be done')


    if args.loop:
        sleep_interval = args.sleep if args.sleep is not None else 5

        while True:
            try:
                time.sleep(sleep_interval)
                create_tex()
                compile_tex(main_tex)
            except KeyboardInterrupt:
                print('Stopped')
                return 0


    if args.open:
        if args.tmp:
            subprocess.call(['open', clatex_dir+'/'+main_pdf])
        else:
            subprocess.call(['open', main_pdf])


if __name__ == '__main__':
    main()
